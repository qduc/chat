# Message Intent Schema

## Overview

This document defines the strict message intent schema that eliminates all heuristic guessing in the backend message synchronization system. The schema is implemented as a lightweight **intent envelope** that wraps every chat request so the backend always knows exactly what operation the frontend expects to perform.

> **Core Principle**  
> The frontend MUST explicitly declare its intent for every message operation. The backend will reject any ambiguous requests.

## Goals

- Encode the user's desired state transition in a single, explicit `intent` object.
- Guarantee that all mutations execute inside a single database transaction.
- Provide deterministic validation errors so the frontend can surface actionable feedback.
- Support optimistic locking semantics that make conflicting edits impossible to miss.
- Preserve the existing REST surface area (`/v1/chat/completions`, `/v1/conversations/:id/messages/:message_id/edit`).

## Data Model Constraints

| Field              | Type    | Notes                                                                                             |
| ------------------ | ------- | ------------------------------------------------------------------------------------------------- |
| `conversation_id`  | string  | UUID generated by backend. Optional for new conversations.                                        |
| `message_id`       | string  | UUID generated by backend.                                                                        |
| `seq`              | number  | Monotonically increasing integer within a conversation. Starts at `1`.                            |
| `role`             | enum    | `"system"`, `"user"`, `"assistant"`, `"tool"`. Only user messages are editable.                  |
| `content`          | mixed   | Either string or structured `MixedContent[]` payload.                                             |
| `client_operation` | string  | Client generated opaque identifier that lets the frontend correlate retries and error responses. |

All intents must respect these invariants:

1. Sequence numbers form a contiguous range with no gaps.  
2. Each message ID is unique within the user account.  
3. Only the authenticated user can mutate conversations they own.  
4. User messages and assistant messages always appear in alternating order once streaming is complete.  
5. All validations check both `message_id` and `seq` (optimistic lock).

## Intent Envelope Structure

All mutating requests include an `intent` object at the root of the JSON body.

```typescript
interface IntentEnvelope {
  intent: AppendMessageIntent | EditMessageIntent;
}
```

### Shared Fields

```typescript
interface BaseIntent {
  /** Unique client generated ID (UUID/ULID/etc). */
  client_operation: string;
  /** Optional ID of the conversation that will be mutated. */
  conversation_id?: string;
  /** Optional metadata emitted back to the client for debugging/telemetry. */
  metadata?: Record<string, unknown>;
}
```

> The backend echoes `client_operation` in every success or error response so the frontend can correlate retries and confirm which speculative UI state should be committed.

## Core Operations

The system provides **two atomic operations**. Each operation corresponds to a distinct intent type and must complete within a single transaction.

### 1. `append_message`

**Endpoint**: `POST /v1/chat/completions`

Adds a new user message (and the resulting assistant response) to a conversation. This intent is also used when a brand new conversation is created.

```typescript
interface AppendMessageIntent extends BaseIntent {
  type: "append_message";
  /**
   * When provided, the newly inserted user message must be placed immediately
   * after this message. Required when conversation_id is provided.
   */
  after_message_id?: string;
  /** Expected sequence number of `after_message_id`. Required when provided. */
  after_seq?: number;
  /**
   * When true, messages with sequence numbers greater than `after_seq` are
   * deleted before the new user/assistant messages are appended.
   */
  truncate_after?: boolean;
  messages: Array<{
    role: "user";
    content: string | MixedContent[];
  }>;
  /** Additional OpenAI-compatible parameters (model, max_tokens, tools, etc). */
  completion: Record<string, unknown>;
}
```

#### Validation Rules

1. If `conversation_id` is omitted: a new conversation is created and `seq` starts at `1` for the user message.  
2. If `conversation_id` is present:  
   - `after_message_id` and `after_seq` MUST be provided.  
   - The referenced conversation must exist and belong to the authenticated user.  
   - The message identified by `after_message_id` must exist with `seq === after_seq`.  
   - When `truncate_after` is `false` (default), `after_message_id` MUST be the message with the highest sequence value.  
   - When `truncate_after` is `true`, any messages with `seq > after_seq` are deleted before the new messages are inserted.

#### Atomic Operation

Within a single transaction the backend:

1. Optionally truncates future messages.  
2. Inserts the new user message at `seq = after_seq + 1`.  
3. Streams or inserts the assistant reply at `seq = after_seq + 2`.  
4. Emits deterministic response metadata (see [Response Format](#response-format)).

#### Failure Modes

| Error Code              | Description                                                                             |
| ----------------------- | --------------------------------------------------------------------------------------- |
| `conversation_not_found`| `conversation_id` does not exist or belongs to another user.                            |
| `message_not_found`     | `after_message_id` cannot be found in the conversation.                                 |
| `seq_mismatch`          | Stored sequence does not equal `after_seq` (optimistic lock failure).                   |
| `not_last_message`      | Attempted append after a non-terminal message without `truncate_after: true`.          |
| `missing_required_field`| Missing `after_message_id`/`after_seq` when `conversation_id` is supplied.              |

#### Typical Use Cases

- **Normal append** – default `truncate_after: false`.  
- **Regeneration** – set `truncate_after: true` to overwrite the previous assistant response.  
- **Mid-conversation fork** – set `truncate_after: true` with an earlier `after_seq` to branch the timeline.

### 2. `edit_message`

**Endpoint**: `PUT /v1/conversations/:conversation_id/messages/:message_id/edit`

Updates the content of an existing **user** message while forking the conversation history that followed it.

```typescript
interface EditMessageIntent extends BaseIntent {
  type: "edit_message";
  /** The message that is being edited (extracted from URL params). */
  message_id: string;
  /** Expected sequence number to enforce optimistic locking. */
  expected_seq: number;
  /** New content for the user message. */
  content: string | MixedContent[];
}
```

#### Validation Rules

1. The target message must exist, belong to the authenticated user, and match the `expected_seq`.  
2. Only `role: "user"` messages can be edited.  
3. The conversation ID in the URL must match the `conversation_id` inside the intent envelope (when provided).

#### Atomic Operation

1. Update the existing user message content in place (ID and sequence remain unchanged).  
2. Delete all messages with `seq > expected_seq` from the original conversation.  
3. Create a forked conversation containing the deleted messages (preserving history).  
4. Return both the original `conversation_id` and the `fork_conversation_id` so the frontend can decide which branch to display.

#### Failure Modes

| Error Code          | Description                                                             |
| ------------------- | ----------------------------------------------------------------------- |
| `message_not_found` | No message with the given ID exists in the conversation.                |
| `seq_mismatch`      | Stored sequence does not equal `expected_seq` (optimistic lock failure). |
| `edit_not_allowed`  | Attempted to edit an assistant or tool message.                         |

## Response Format

All successful operations return the following payload. Lists are empty arrays when nothing was inserted/updated/deleted.

```typescript
interface IntentSuccessResponse {
  success: true;
  conversation_id: string;
  client_operation: string;
  operations: {
    inserted: Array<{ id: string; seq: number; role: string }>;
    updated: Array<{ id: string; seq: number; role: string }>;
    deleted: Array<{ id: string; seq: number; role: string }>;
  };
  fork_conversation_id?: string; // Present only for edit operations.
  metadata?: Record<string, unknown>; // Echoes the original intent metadata when provided.
}
```

> The `operations` object enables granular reconciliation in the frontend reducer. The UI can add, update, or remove messages without re-fetching the entire conversation.

## Error Format

All validation errors respond with HTTP `400` and the following structure:

```typescript
interface IntentErrorResponse {
  success: false;
  error: "validation_error";
  error_code: string;
  message: string;
  client_operation?: string;
  details?: {
    field: string;
    expected?: unknown;
    actual?: unknown;
  };
}
```

- `client_operation` is echoed when the request included one.  
- Additional HTTP status codes may be used for authentication/authorization errors but should still include the same shape.

## Logging & Telemetry

- Every intent must be logged with the tuple `(user_id, conversation_id, client_operation, type, after_seq/expected_seq, truncate_after)`.  
- Structured logs enable reconstruction of the event timeline without relying on database diffs.  
- Metrics should emit counters for each `type` and histogram buckets for validation failures to monitor UX friction.

## Migration Strategy

The rollout is intentionally incremental so both frontend and backend can deploy safely without coordinated downtime. Each phase
builds on the previous one and should only begin once the success criteria of the prior phase have been met.

### Phase 1 – Backend compatibility release

- Ship backend changes that understand the `intent` envelope for `append_message` and `edit_message` while still accepting
  legacy payloads.
- Gate the new parsing logic behind a feature flag so that the change can be disabled without redeploying.
- Add unit/integration tests that cover both request formats to prevent regressions while the rollout is incomplete.
- Validate that logging captures whether the request arrived with or without an intent to support adoption dashboards.
- Success criteria: production logs confirm at least 99% of requests continue to succeed with no increase in latency or error
  rates.

### Phase 2 – Frontend adoption

- Gradually roll out intent-enabled clients (behind a remote kill switch) starting with internal dogfood environments.
- For every mutation, populate `client_operation`, `intent.type`, and the required fields; continue to accept legacy response
  shapes from the backend.
- Monitor telemetry added in Phase 1 to verify the percentage of intent-carrying requests increases over time.
- Update QA scripts and end-to-end tests so they assert that intents are present in recorded network calls.
- Success criteria: 100% of production user mutations include a well-formed intent for at least 24 hours.

### Phase 3 – Warning mode

- Flip the backend flag to emit structured warnings (`intent_missing`) when a request arrives without the envelope.
- Page the owning team if the warning rate exceeds 0.1% for more than 10 consecutive minutes.
- Expose the warning metric on the shared rollout dashboard and communicate the deprecation date to dependent teams.
- Success criteria: warning volume remains effectively zero for one full release cycle (minimum one week).

### Phase 4 – Strict enforcement

- Remove the legacy parsing path and require all requests to include a valid intent object.
- Update API documentation and SDKs to mark the old format as unsupported.
- Keep the warnings/metrics from Phase 3 in place for an additional release to ensure the hard cutover is stable.
- Success criteria: zero regression in message mutation success rate and no alerts for missing intents after the switch.

## Benefits

1. **No ambiguity** – The backend never has to guess the desired operation.  
2. **Optimistic locking** – Sequence validation detects concurrent edits immediately.  
3. **Deterministic reconciliation** – The reducer can diff messages using the `operations` payload.  
4. **Improved observability** – Every state transition carries a `client_operation` correlation ID.  
5. **Safer concurrency** – Forking behavior is explicit and race conditions are surfaced instead of silently clobbered.  
6. **Future extensibility** – Additional operations (e.g., delete, tool-run cancellation) can extend the intent union without touching existing handlers.
